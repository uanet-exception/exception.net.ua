---
author: "ZEN"
title: "Розбиваємо файл на декілька інших файлів за фільтром"
# description: ""
date: 2020-07-26T23:19:09+03:00
lastmod: 2020-07-26T23:19:09+03:00
tags:
  - "linux"
  - "bash"
  - "awk"
  - "tee"
  - "grep"
categories:
  - "Desktop"
  - "Administration"
draft: false
type: "post"
archives: "2020"
---

Іноді стикаюсь з тим, що треба розбити великий файл на декілька менших і при цьому зміст нових файлів повинен відповідати певним фільтрам. І сьогодні я розповім, як вирішити цю проблему за допомогою bash-скрипту.

<!--more-->

Для початку, нам потрібен файл з тестовими даними, що містить нулі, одиниці та двійки. Згенеруємо його наступною командою:

{{< highlight plaintext >}}
$ seq 1000 | awk '{print $0 % 3}' > /tmp/data.txt
{{< /highlight >}}

А тепер, саме цікаве, ми візьмемо вивід команди `cat` та за допомогою `tee` перенаправимо його на введення команді `grep`, яка за необхідним шаблоном відфільтрує текст у потрібний файл:

{{< highlight html "linenos=table" >}}
cat /tmp/data.txt \
    | tee >(grep "^0$" > /tmp/0.txt) \
    | tee >(grep "^1$" > /tmp/1.txt) \
    | tee >(grep "^2$" > /tmp/2.txt) \
    > /dev/null
{{< /highlight >}}

Як видно з коду, на виході ми отримаємо три файли - `/tmp/0.txt`, `/tmp/1.txt` та `/tmp/2.txt`. Перенаправлення у `/dev/null` в останньому рядку потрібно, аби не виводити зміст файлу `/tmp/data.txt` на термінал. Втім, якщо вам потрібна копія файлу, ви можете перенаправити виведення в інший файл.

Що ж, виконуємо команду та перевіряємо результат:

{{< highlight plaintext >}}
$ head -n2 /tmp/{0,1,2}.txt
==> 0.txt <==
0
0

==> 1.txt <==
1
1

==> 2.txt <==
2
2
$ wc -l /tmp/{0,1,2}.txt
 333 /tmp/0.txt
 334 /tmp/1.txt
 333 /tmp/2.txt
1000 total
{{< /highlight >}}

Якщо ви у вас схожий результат - поздоровляю, ви навчились новому трюку в bash. ;)
